% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parallelisingWrappers.R
\name{parallelWrapper}
\alias{parallelWrapper}
\title{Parallelisation with external pointers}
\usage{
parallelWrapper(foo, ptrFoo, ptrArg, argName, ptrElem = NULL, ...)
}
\arguments{
\item{foo}{function to be wrapped}

\item{ptrFoo}{function that finds pointer, takes a single argument}

\item{ptrArg}{argument to ptrFoo}

\item{argName}{character, name of the pointer argument in foo; for example \code{'jumpTransform'} if you want to call \code{\link{affineCF}}}

\item{ptrElem}{character, if \code{ptrFoo} returns a named list, get pointer in field \code{ptrFoo(ptrArg)$ptrElem}.}
}
\value{
Returns a function that which should be called with the same arguments as \code{foo} except for the pointer arguments.
}
\description{
Parallelising calls to R functions in this package while using the pointer-passing interface requires some care: the \code{\link{getPointerToJumpTransform}} and \code{\link{getPointerToGenerator}} functions have to be called \emph{on the cluster}; a call such as \code{parLapply(cl = myCluster, X = uMat.list, fun = affineCF, params.Q = params.Q, params.P = params.P, t.vec = 0.15, v.0 = matrix(0.025,1,1), N.factors = 1, jumpTransform = getPointerToJumpTransform('kouExpJumpTransform'))} will fail because of invalid pointers. This interface delays evaluation of the pointer functions by wrapping the call appropriately.
}
\details{
Further functions are ready parallel versions of the CF callers.
}
